// Generated by CoffeeScript 1.3.3
(function() {
  var CanvasManager;

  CanvasManager = (function() {

    function CanvasManager(id) {
      if (document.getElementById(id)) {
        this.canvas3D = document.getElementById(id);
      } else {
        console.error('cant access canvas id ' + id);
        return;
      }
      this.shaderProgram = null;
      this.triangleVertexPositionBuffer = null;
      this.squareVertexPositionBuffer = null;
      this.mvMatrix = mat4.create();
      this.pMatrix = mat4.create();
      this.init();
    }

    CanvasManager.prototype.init = function() {
      this.initGL();
      this.initShaders();
      this.initBuffers();
      this.gl.clearColor(0.0, 0.0, 0.0, 1.0);
      this.gl.enable(this.gl.DEPTH_TEST);
      return this.drawScene();
    };

    CanvasManager.prototype.initGL = function() {
      try {
        this.gl = this.canvas3D.getContext("experimental-webgl");
        this.gl.viewportWidth = this.canvas3D.width;
        this.gl.viewportHeight = this.canvas3D.height;
      } catch (e) {
        console.log('catched : ' + e);
      }
      if (!this.gl) {
        return alert("Could not initialise WebGL, sorry :-(");
      }
    };

    CanvasManager.prototype.getShader = function(gl, id) {
      var k, shader, shaderScript, str;
      shaderScript = document.getElementById(id);
      if (!shaderScript) {
        return null;
      }
      str = "";
      k = shaderScript.firstChild;
      while (k) {
        if (k.nodeType === 3) {
          str += k.textContent;
        }
        k = k.nextSibling;
      }
      if (shaderScript.type === "x-shader/x-fragment") {
        shader = gl.createShader(gl.FRAGMENT_SHADER);
      } else if (shaderScript.type === "x-shader/x-vertex") {
        shader = gl.createShader(gl.VERTEX_SHADER);
      } else {
        return null;
      }
      gl.shaderSource(shader, str);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert("getShader : " + gl.getShaderInfoLog(shader));
        return null;
      }
      return shader;
    };

    CanvasManager.prototype.initShaders = function() {
      var fragmentShader, vertexShader;
      fragmentShader = this.getShader(this.gl, "shader-fs");
      vertexShader = this.getShader(this.gl, "shader-vs");
      this.shaderProgram = this.gl.createProgram();
      this.gl.attachShader(this.shaderProgram, vertexShader);
      this.gl.attachShader(this.shaderProgram, fragmentShader);
      this.gl.linkProgram(this.shaderProgram);
      if (!this.gl.getProgramParameter(this.shaderProgram, this.gl.LINK_STATUS)) {
        alert("Could not initialise shaders");
      }
      this.gl.useProgram(this.shaderProgram);
      this.shaderProgram.vertexPositionAttribute = this.gl.getAttribLocation(this.shaderProgram, "aVertexPosition");
      this.gl.enableVertexAttribArray(this.shaderProgram.vertexPositionAttribute);
      this.shaderProgram.pMatrixUniform = this.gl.getUniformLocation(this.shaderProgram, "upMatrix");
      return this.shaderProgram.mvMatrixUniform = this.gl.getUniformLocation(this.shaderProgram, "umvMatrix");
    };

    CanvasManager.prototype.setMatrixUniforms = function() {
      this.gl.uniformMatrix4fv(this.shaderProgram.pMatrixUniform, false, this.pMatrix);
      return this.gl.uniformMatrix4fv(this.shaderProgram.mvMatrixUniform, false, this.mvMatrix);
    };

    CanvasManager.prototype.initBuffers = function() {
      var vertices;
      this.triangleVertexPositionBuffer = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.triangleVertexPositionBuffer);
      vertices = [0.0, 1.0, 0.0, -1.0, -1.0, 0.0, 1.0, -1.0, 0.0];
      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.STATIC_DRAW);
      this.triangleVertexPositionBuffer.itemSize = 3;
      return this.triangleVertexPositionBuffer.numItems = 3;
    };

    CanvasManager.prototype.drawScene = function(video) {
      var buffer, texture, vertices;
      this.gl.viewport(0, 0, this.gl.viewportWidth, this.gl.viewportHeight);
      this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
      mat4.perspective(45, this.gl.viewportWidth / this.gl.viewportHeight, 0.1, 100.0, this.pMatrix);
      mat4.identity(this.mvMatrix);
      buffer = this.gl.createBuffer();
      vertices = [1.0, 1.0, 0.0, -1.0, 1.0, 0.0, 1.0, -1.0, 0.0, -1.0, -1.0, 0.0];
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.STATIC_DRAW);
      this.gl.enableVertexAttribArray(this.shaderProgram.vertexPositionAttribute);
      this.gl.vertexAttribPointer(this.shaderProgram.vertexPositionAttribute, 3, this.gl.FLOAT, false, 0, 0);
      texture = this.gl.createTexture();
      this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
      this.gl.bindTexture(this.gl.TEXTURE_2D, null);
      if (video != null) {
        this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, video);
        this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
      }
      mat4.translate(this.mvMatrix, [-1.5, 0.0, -7.0]);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.triangleVertexPositionBuffer);
      this.gl.vertexAttribPointer(this.shaderProgram.vertexPositionAttribute, this.triangleVertexPositionBuffer.itemSize, this.gl.FLOAT, false, 0, 0);
      return this.gl.drawArrays(this.gl.triangleS, 0, this.triangleVertexPositionBuffer.numItems);
    };

    return CanvasManager;

  })();

  window.CanvasManager = CanvasManager;

}).call(this);
