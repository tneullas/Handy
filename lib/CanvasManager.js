// Generated by CoffeeScript 1.3.3
(function() {
  var CanvasManager;

  CanvasManager = (function() {

    function CanvasManager(id) {
      if (document.getElementById(id)) {
        this.canvas3D = document.getElementById(id);
      } else {
        console.error('cant access canvas id ' + id);
        return;
      }
      this.shaderProgram = null;
      this.squareVertexPositionBuffer = null;
      this.squareVertexTextureCoordBuffer = null;
      this.squareVertexIndexBuffer = null;
      this.mvMatrix = mat4.create();
      this.pMatrix = mat4.create();
      this.init();
    }

    CanvasManager.prototype.init = function() {
      this.initGL();
      this.initShaders();
      return this.initBuffers();
    };

    CanvasManager.prototype.initGL = function() {
      try {
        this.gl = this.canvas3D.getContext("experimental-webgl");
        this.gl.viewportWidth = this.canvas3D.width;
        this.gl.viewportHeight = this.canvas3D.height;
      } catch (e) {
        console.log('catched : ' + e);
      }
      if (!this.gl) {
        return alert("Could not initialise WebGL, sorry :-(");
      }
    };

    CanvasManager.prototype.getShader = function(gl, id) {
      var k, shader, shaderScript, str;
      shaderScript = document.getElementById(id);
      if (!shaderScript) {
        return null;
      }
      str = "";
      k = shaderScript.firstChild;
      while (k) {
        if (k.nodeType === 3) {
          str += k.textContent;
        }
        k = k.nextSibling;
      }
      if (shaderScript.type === "x-shader/x-fragment") {
        shader = gl.createShader(gl.FRAGMENT_SHADER);
      } else if (shaderScript.type === "x-shader/x-vertex") {
        shader = gl.createShader(gl.VERTEX_SHADER);
      } else {
        return null;
      }
      gl.shaderSource(shader, str);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert("getShader : " + gl.getShaderInfoLog(shader));
        return null;
      }
      return shader;
    };

    CanvasManager.prototype.addVariableToShaders = function(name, data) {
      var variableIndex;
      variableIndex = this.gl.getUniformLocation(this.shaderProgram, name);
      return this.gl.uniform1f(variableIndex, data);
    };

    CanvasManager.prototype.addVectorToShaders = function(name, data) {
      var variableIndex;
      variableIndex = this.gl.getUniformLocation(this.shaderProgram, name);
      return this.gl.uniform4fv(variableIndex, data);
    };

    CanvasManager.prototype.addTextureToShaders = function(name, data) {
      var texture;
      texture = this.gl.createTexture();
      this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
      this.gl.activeTexture(this.gl.TEXTURE1);
      this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, data);
      return this.gl.uniform1i(this.gl.getUniformLocation(this.shaderProgram, name), 0);
    };

    CanvasManager.prototype.initShaders = function() {
      var fragmentShader, vertexShader;
      fragmentShader = this.getShader(this.gl, "shader-fs");
      vertexShader = this.getShader(this.gl, "shader-vs");
      this.shaderProgram = this.gl.createProgram();
      this.gl.attachShader(this.shaderProgram, vertexShader);
      this.gl.attachShader(this.shaderProgram, fragmentShader);
      this.gl.linkProgram(this.shaderProgram);
      if (!this.gl.getProgramParameter(this.shaderProgram, this.gl.LINK_STATUS)) {
        alert("Could not initialise shaders");
      }
      this.gl.useProgram(this.shaderProgram);
      this.shaderProgram.vertexPositionAttribute = this.gl.getAttribLocation(this.shaderProgram, "aVertexPosition");
      this.gl.enableVertexAttribArray(this.shaderProgram.vertexPositionAttribute);
      this.shaderProgram.textureCoordAttribute = this.gl.getAttribLocation(this.shaderProgram, "aTextureCoord");
      this.gl.enableVertexAttribArray(this.shaderProgram.textureCoordAttribute);
      this.shaderProgram.pMatrixUniform = this.gl.getUniformLocation(this.shaderProgram, "uPMatrix");
      return this.shaderProgram.mvMatrixUniform = this.gl.getUniformLocation(this.shaderProgram, "uMVMatrix");
    };

    CanvasManager.prototype.setMatrixUniforms = function() {
      this.gl.uniformMatrix4fv(this.shaderProgram.pMatrixUniform, false, this.pMatrix);
      return this.gl.uniformMatrix4fv(this.shaderProgram.mvMatrixUniform, false, this.mvMatrix);
    };

    CanvasManager.prototype.initBuffers = function() {
      var squareVertexIndices, textureCoords, vertices;
      this.squareVertexPositionBuffer = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.squareVertexPositionBuffer);
      vertices = [1.0, 1.0, 0.0, -1.0, 1.0, 0.0, -1.0, -1.0, 0.0, 1.0, -1.0, 0.0];
      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.STATIC_DRAW);
      this.squareVertexPositionBuffer.itemSize = 3;
      this.squareVertexPositionBuffer.numItems = 4;
      this.squareVertexTextureCoordBuffer = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.squareVertexTextureCoordBuffer);
      textureCoords = [0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0];
      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(textureCoords), this.gl.STATIC_DRAW);
      this.squareVertexTextureCoordBuffer.itemSize = 2;
      this.squareVertexTextureCoordBuffer.numItems = 4;
      this.squareVertexIndexBuffer = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.squareVertexIndexBuffer);
      squareVertexIndices = [0, 1, 2, 0, 2, 3];
      this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(squareVertexIndices), this.gl.STATIC_DRAW);
      this.squareVertexIndexBuffer.itemSize = 1;
      return this.squareVertexIndexBuffer.numItems = 6;
    };

    CanvasManager.prototype.drawScene = function(video) {
      var texture;
      this.gl.clearColor(0.0, 0.0, 0.0, 1.0);
      this.gl.enable(this.gl.DEPTH_TEST);
      this.gl.viewport(0, 0, this.gl.viewportWidth, this.gl.viewportHeight);
      this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
      mat4.perspective(45, this.gl.viewportWidth / this.gl.viewportHeight, 0.1, 100.0, this.pMatrix);
      mat4.identity(this.mvMatrix);
      if (video != null) {
        texture = this.gl.createTexture();
        this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
        this.gl.bindTexture(this.gl.TEXTURE_2D, null);
        mat4.translate(this.mvMatrix, [0.0, 0.0, -2.5]);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.squareVertexPositionBuffer);
        this.gl.vertexAttribPointer(this.shaderProgram.vertexPositionAttribute, this.squareVertexPositionBuffer.itemSize, this.gl.FLOAT, false, 0, 0);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.squareVertexTextureCoordBuffer);
        this.gl.vertexAttribPointer(this.shaderProgram.textureCoordAttribute, this.squareVertexTextureCoordBuffer.itemSize, this.gl.FLOAT, false, 0, 0);
        this.gl.activeTexture(this.gl.TEXTURE0);
        this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, video);
        this.gl.uniform1i(this.shaderProgram.webcam, 0);
        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.squareVertexIndexBuffer);
        this.setMatrixUniforms();
        return this.gl.drawElements(this.gl.TRIANGLES, this.squareVertexIndexBuffer.numItems, this.gl.UNSIGNED_SHORT, 0);
      }
    };

    return CanvasManager;

  })();

  window.CanvasManager = CanvasManager;

}).call(this);
